<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2012 (1.2)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Subroutine mld_precset</TITLE>
<META NAME="description" CONTENT="Subroutine mld_precset">
<META NAME="keywords" CONTENT="userhtml">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2012">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="userhtml.css">

<LINK REL="next" HREF="node19.html">
<LINK REL="previous" HREF="node17.html">
<LINK REL="up" HREF="node16.html">
<LINK REL="next" HREF="node19.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html284"
  HREF="node19.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html280"
  HREF="node16.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html274"
  HREF="node17.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html282"
  HREF="node2.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html285"
  HREF="node19.html">Subroutine mld_precbld</A>
<B> Up:</B> <A NAME="tex2html281"
  HREF="node16.html">User Interface</A>
<B> Previous:</B> <A NAME="tex2html275"
  HREF="node17.html">Subroutine mld_precinit</A>
 &nbsp; <B>  <A NAME="tex2html283"
  HREF="node2.html">Contents</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<H2><A NAME="SECTION00082000000000000000"></A><A NAME="sec:precset"></A>
<BR>
Subroutine mld_precset
</H2>

<P>
<DIV ALIGN="CENTER">
<code>call mld_precset(p,what,val,info)</code>

</DIV>

<P>
This routine sets the parameters defining the preconditioner. More
precisely, the parameter identified by <code>what</code> is assigned the value
contained in <code>val</code>. 

<P>
The routine may also be invoked as a method
of the preconditioner object as in the following:
<DIV ALIGN="CENTER">
<code>call p%set(what,val,info [,ilev])</code>
<BR>
</DIV>
In this case it is also possible to specify an optional <code>ilev</code>
argument that restricts the effect of 
the call to the specified level.

<P>
Finally, if the user has developed  a new type of smoother and/or
solver by extending one of the base MLD2P4 types, and has declared a
variable of the new  type in the main program, it is possible to pass
the new smoother/solver variable  to the setup routine as follows:
<DIV ALIGN="CENTER">
<code>call p%set(smoother,info [,ilev])</code>
<BR><code>call p%set(solver,info [,ilev])</code>

</DIV>
In this way, the variable will act as a <SPAN  CLASS="textit">mold</SPAN> to which the
preconditioner will conform, even though the MLD2P4 library is not
modified, and thus has no direct knowledge about the new type. 

<P>
<BIG CLASS="LARGE"><B>Arguments</B></BIG>

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=34><code>p</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340><code>type(mld_</code><SPAN  CLASS="textit">x</SPAN><code>prec_type), intent(inout)</code>.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=34>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>The preconditioner data structure. Note that <SPAN  CLASS="textit">x</SPAN> must
                be chosen according to the real/complex, single/double precision
                 version of MLD2P4 under use.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=34><code>what</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340><code>integer, intent(in)</code> <SPAN  CLASS="textit">or</SPAN> <code>character(len=*)</code>.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=34>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>The parameter to be set. It can be specified by 
                a predefined constant, or through its name; the string
                is case-insensitive. See also
                Tables&nbsp;<A HREF="#tab:p_type">2</A>-<A HREF="#tab:p_coarse">5</A>.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=34><code>val </code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340><code>integer</code> <SPAN  CLASS="textit">or</SPAN> <code>character(len=*)</code> <SPAN  CLASS="textit">or</SPAN>
                <code>real(psb_spk_)</code> <SPAN  CLASS="textit">or</SPAN> <code>real(psb_dpk_)</code>,
                <code>intent(in)</code>.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=34>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>The value of the parameter to be set. The list of allowed
                values and the corresponding data types is given in
                Tables&nbsp;<A HREF="#tab:p_type">2</A>-<A HREF="#tab:p_coarse">5</A>.
                When the value is of type <code>character(len=*)</code>,
                it is also treated as case insensitive.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=34><code>smoother</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340><code>class(mld_x_base_smoother_type)</code></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=34>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>The user-defined new smoother to be employed in the
                preconditioner.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=34><code>solver</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340><code>class(mld_x_base_solver_type)</code></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=34>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>The user-defined new solver to be employed in the
                preconditioner.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=34><code>info</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340><code>integer, intent(out)</code>.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=34>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>Error code. If no error, 0 is returned. See Section&nbsp;<A HREF="node23.html#sec:errors">7</A>
                for details.</TD>
</TR>
</TABLE>

<P>
 
<BR>
A variety of (one-level and multi-level) preconditioners can be obtained
by a suitable setting of the preconditioner parameters. These parameters
can be logically divided into four groups, i.e. parameters defining

<OL>
<LI>the type of multi-level preconditioner;
</LI>
<LI>the one-level preconditioner used as smoother;
</LI>
<LI>the aggregation algorithm;
</LI>
<LI>the coarse-space correction at the coarsest level.
</LI>
</OL>
A list of the parameters that can be set, along with their allowed and
default values, is given in Tables&nbsp;<A HREF="#tab:p_type">2</A>-<A HREF="#tab:p_coarse">5</A>.
For a detailed description  of the meaning of the parameters, please
refer to Section&nbsp;<A HREF="node11.html#sec:background">4</A>. 

<P>
The smoother and solver objects are arranged in a hierarchical manner;
when specifying a smoother object, its parameters including the
contained solver are set to  default values, and when a solver
object is specified its defaults are also set, overriding in both
cases any previous settings even if explicitly specified. Therefore if
the user sets a new smoother, and wishes to use a solver
different from  the default one, the call to set the solver must come
<SPAN  CLASS="textit">after</SPAN> the call to set the smoother. 
<P>
The combination of a Jacobi smoother with a Diagonal Scaling local
solver is equivalent to the strategy called Point Jacobi in the
literature; similarly, having a Jacobi smoother with a Gauss-Seidel
local solver is equivalent to a ``hybrid Gauss-Seidel'' solver. 

<P>
Completely new smoother and/or  solver class derived from the
base objects in the library may be used without recompiling the
library itself. Once the new smoother/solver  class has been
developed, the user can declare a variable of that new type in the
application, and pass that variable to the <code>p%set(solver,info)</code>
call; the new solver object is then dynamically included in the
preconditioner structure. 

<P>
The <code>what,val</code> pairs described here are those of the predefined
smoother/solver objects; newly developed solvers may define new pairs
according to their needs. 

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="1271"></A>
<TABLE>
<CAPTION><STRONG>Table 2:</STRONG>
Parameters defining the type of multi-level preconditioner.
</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1" ALIGN="CENTER">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><code>what</code></TD>
<TD ALIGN="LEFT"><SMALL>DATA TYPE</SMALL></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><code>val</code></TD>
<TD ALIGN="LEFT"><SMALL>DEFAULT</SMALL></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><SMALL>COMMENTS</SMALL></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><code>mld_ml_type_</code> <BR><code>ML_TYPE</code></TD>
<TD ALIGN="LEFT"><code>character(len=*)</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>'ADD'</TT>    <TT>'MULT'</TT></TD>
<TD ALIGN="LEFT"><TT>'MULT'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>Basic multi-level framework: additive or multiplicative
                           among the levels (always additive inside a level).</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><code>mld_smoother_type_</code> <BR><code>SMOOTHER_TYPE</code></TD>
<TD ALIGN="LEFT"><code>character(len=*)</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>'JACOBI'</TT>    <TT>'BJAC'</TT>    <TT>'AS'</TT></TD>
<TD ALIGN="LEFT"><TT>'AS'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>Basic predefined one-level preconditioner
                         (i.e. smoother): Jacobi, block Jacobi, AS.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><code>mld_smoother_pos_</code> <BR><code>SMOOTHER_POS</code></TD>
<TD ALIGN="LEFT"><code>character(len=*)</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>'PRE'</TT>    <TT>'POST'</TT>    <TT>'TWOSIDE'</TT></TD>
<TD ALIGN="LEFT"><TT>'TWOSIDE'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>``Position'' of the smoother: pre-smoother, post-smoother, 
                           pre- and post-smoother.</TD>
</TR>
</TABLE>
</DIV>
</TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="1273"></A>
<TABLE>
<CAPTION><STRONG>Table 3:</STRONG>
Parameters defining the one-level preconditioner used as smoother.
</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1" ALIGN="CENTER">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><code>what</code></TD>
<TD ALIGN="LEFT"><SMALL>DATA TYPE</SMALL></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91><code>val</code></TD>
<TD ALIGN="LEFT"><SMALL>DEFAULT</SMALL></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SMALL>COMMENTS</SMALL></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><code>mld_sub_ovr_</code>  <BR><code>SUB_OVR</code></TD>
<TD ALIGN="LEFT"><code>integer</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91>any&nbsp;int.&nbsp;num.&nbsp;<SPAN CLASS="MATH"><IMG
 WIDTH="32" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img90.png"
 ALT="$\ge 0$"></SPAN></TD>
<TD ALIGN="LEFT">1</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Number of overlap layers.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><code>mld_sub_restr_</code>  <BR><code>SUB_RESTR</code></TD>
<TD ALIGN="LEFT"><code>character(len=*)</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91><TT>'HALO'</TT>   <TT>'NONE'</TT></TD>
<TD ALIGN="LEFT"><TT>'HALO'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Type of restriction operator:
                           <TT>'HALO'</TT> for taking into account the overlap, <TT>'NONE'</TT> 
                           for neglecting it.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><code>mld_sub_prol_</code> <BR><code>SUB_PROL</code></TD>
<TD ALIGN="LEFT"><code>character(len=*)</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91><TT>'SUM'</TT>   <TT>'NONE'</TT></TD>
<TD ALIGN="LEFT"><TT>'NONE'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Type of prolongation operator:
                           <TT>'SUM'</TT> for adding the contributions from the overlap, <TT>'NONE'</TT>
                           for neglecting them.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><code>mld_sub_solve_</code> <BR><code>SUB_SOLVE</code></TD>
<TD ALIGN="LEFT"><code>character(len=*)</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91><TT>'DIAG'</TT>  
                           <TT>'GS'</TT>  
                           <TT>'ILU'</TT>   
                           <TT>'MILU'</TT>   <TT>'ILUT'</TT> 
                             <TT>'UMF'</TT>   <TT>'SLU'</TT></TD>
<TD ALIGN="LEFT"><TT>'ILU'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Predefined local solver: pointwise Jacobi
                           (diagonal scaling),
                           Gauss-Seidel, ILU(<IMG
 WIDTH="13" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img35.png"
 ALT="$p$">),  MILU(<IMG
 WIDTH="13" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img35.png"
 ALT="$p$">),
                           ILU(<IMG
 WIDTH="27" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img36.png"
 ALT="$p,t$">), LU from UMFPACK, LU  from
                           SuperLU (plus triangular solve).</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><code>mld_sub_fillin_</code> <BR><code>SUB_FILLIN</code></TD>
<TD ALIGN="LEFT"><code>integer</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91>Any&nbsp;int.&nbsp;num.&nbsp;<SPAN CLASS="MATH"><IMG
 WIDTH="32" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img90.png"
 ALT="$\ge 0$"></SPAN></TD>
<TD ALIGN="LEFT">0</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Fill-in level <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img35.png"
 ALT="$p$"></SPAN> of the incomplete LU factorizations.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><code>mld_sub_iluthrs_</code> <BR><code>SUB_ILUTHRS</code></TD>
<TD ALIGN="LEFT"><code>real(</code><SPAN  CLASS="textit">kind_parameter</SPAN><code>)</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91>Any&nbsp;real&nbsp;num.&nbsp;<SPAN CLASS="MATH"><IMG
 WIDTH="32" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img90.png"
 ALT="$\ge 0$"></SPAN></TD>
<TD ALIGN="LEFT">0</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Drop tolerance <SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img91.png"
 ALT="$t$"></SPAN> in the ILU(<SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img36.png"
 ALT="$p,t$"></SPAN>) factorization.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><code>mld_sub_ren_</code> <BR><code>SUB_REN</code></TD>
<TD ALIGN="LEFT"><code>character(len=*)</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91><TT>'RENUM_NONE'</TT>  <TT>'RENUM_GLOBAL'</TT> </TD>
<TD ALIGN="LEFT"><TT>'RENUM_NONE'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Row and column reordering of the local submatrices: no reordering,
                           reordering according to the global numbering of the rows and columns of
                           the whole matrix.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><code>mld_solver_sweeps_</code> <BR><code>SOLVER_SWEEPS</code></TD>
<TD ALIGN="LEFT"><code>integer</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91>Any&nbsp;int.&nbsp;num.&nbsp;<IMG
 WIDTH="31" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img92.png"
 ALT="$\ge 1$"></TD>
<TD ALIGN="LEFT">1</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Number of sweeps for iterative local solver
                           (currently only Gauss-Seidel).</TD>
</TR>
</TABLE>
</DIV>
</TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="1275"></A>
<TABLE>
<CAPTION><STRONG>Table 4:</STRONG>
Parameters defining the aggregation algorithm.
</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1" ALIGN="CENTER">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><code>what</code></TD>
<TD ALIGN="LEFT"><SMALL>DATA TYPE</SMALL></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=68><code>val</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=68><SMALL>DEFAULT</SMALL></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><SMALL>COMMENTS</SMALL></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><code>mld_coarse_aggr_size_</code>  <BR><code>COARSE_AGGR_SIZE</code></TD>
<TD ALIGN="LEFT"><code>integer</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=68>A positive number</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=68>0, meaning that the size is fixed at
                         <code>precinit</code> time</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>Coarse size threshold. Disregard the
                         original specification of number of levels in
                         <code>precinit</code> and continue aggregation
                         until either the global number of variables
                         is below this threshold, or the aggregation
                         does not reduce the size any longer.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><code>mld_aggr_alg_</code>  <BR><code>AGGR_ALG</code></TD>
<TD ALIGN="LEFT"><code>character(len=*)</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=68><TT>'DEC'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=68><TT>'DEC'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>Aggregation algorithm. Currently, only the
                         decoupled aggregation is available.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><code>mld_aggr_kind_</code>  <BR><code>AGGR_KIND</code></TD>
<TD ALIGN="LEFT"><code>character(len=*)</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=68><TT>'SMOOTHED'</TT>   <TT>'NONSMOOTHED'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=68><TT>'SMOOTHED'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>Type of aggregation: smoothed, nonsmoothed
                         (i.e. using the tentative prolongator).</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><code>mld_aggr_thresh_</code> <BR><code>AGGR_THRESH</code></TD>
<TD ALIGN="LEFT"><code>real(</code><SPAN  CLASS="textit">kind_parameter</SPAN><code>)</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=68>Any&nbsp;real&nbsp;num. <SPAN CLASS="MATH"><IMG
 WIDTH="56" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img93.png"
 ALT="$\in [0, 1]$"></SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=68>0.05</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>Threshold <IMG
 WIDTH="13" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img94.png"
 ALT="$\theta$"></SPAN> in the aggregation algorithm.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><code>mld_aggr_scale_</code> <BR><code>AGGR_SCALE</code></TD>
<TD ALIGN="LEFT"><code>real(</code><I>kind_parameter</I><code>)</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=68>Any&nbsp;real&nbsp;num. <IMG
 WIDTH="56" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img93.png"
 ALT="$\in [0, 1]$"></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=68>1.0</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>Scale factor applied to the threshold going
 from level <IMG
 WIDTH="33" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img95.png"
 ALT="$ilev$"> to level <IMG
 WIDTH="63" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img96.png"
 ALT="$ilev+1$">.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><code>mld_aggr_omega_alg_</code>  <BR><code>AGGR_OMEGA_ALG</code></TD>
<TD ALIGN="LEFT"><code>character(len=*)</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=68><TT>'EIG_EST'</TT>   <TT>'USER_CHOICE'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=68><TT>'EIG_EST'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>How the damping parameter <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img86.png"
 ALT="$\omega$"></SPAN> in the
                         smoothed aggregation should be computed:
                         either via an estimate of the spectral radius of
                         <SPAN CLASS="MATH"><IMG
 WIDTH="50" HEIGHT="21" ALIGN="BOTTOM" BORDER="0"
 SRC="img87.png"
 ALT="$D^{-1}A$"></SPAN>, or explicily
                         specified by the user.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><code>mld_aggr_eig_</code>  <BR><code>AGGR_EIG</code></TD>
<TD ALIGN="LEFT"><code>character(len=*)</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=68><TT>'A_NORMI'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=68><TT>'A_NORMI'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>How to estimate the spectral radius of <SPAN CLASS="MATH"><IMG
 WIDTH="50" HEIGHT="21" ALIGN="BOTTOM" BORDER="0"
 SRC="img87.png"
 ALT="$D^{-1}A$"></SPAN>.
                           Currently only the infinity norm estimate
                           is available.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><code>mld_aggr_omega_val_</code> <BR><code>AGGR_OMEGA_VAL</code></TD>
<TD ALIGN="LEFT"><code>real(</code><SPAN  CLASS="textit">kind_parameter</SPAN><code>)</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=68>Any&nbsp;nonnegative&nbsp;real&nbsp;num.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=68><!-- MATH
 $4/(3\rho(D^{-1}A))$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="113" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="img97.png"
 ALT="$4/(3\rho(D^{-1}A))$"></SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>Damping parameter <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img86.png"
 ALT="$\omega$"></SPAN> in the smoothed aggregation algorithm. 
                           It must be set by the user if
                           <code>USER_CHOICE</code> was specified for 
                           <code>mld_aggr_omega_alg_</code>,
                           otherwise it is computed by the library, using the
                           selected estimate of the spectral radius <SPAN CLASS="MATH"><IMG
 WIDTH="73" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="img98.png"
 ALT="$\rho(D^{-1}A)$"></SPAN> of
                           <SPAN CLASS="MATH"><IMG
 WIDTH="50" HEIGHT="21" ALIGN="BOTTOM" BORDER="0"
 SRC="img87.png"
 ALT="$D^{-1}A$"></SPAN>.</TD>
</TR>
</TABLE>
</DIV>
</TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="1278"></A>
<TABLE>
<CAPTION><STRONG>Table 5:</STRONG>
Parameters defining the coarse-space correction at the coarsest
level.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1" ALIGN="CENTER">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><code>what</code></TD>
<TD ALIGN="LEFT"><SMALL>DATA TYPE</SMALL></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91><code>val</code></TD>
<TD ALIGN="LEFT"><SMALL>DEFAULT</SMALL></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><SMALL>COMMENTS</SMALL></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><code>mld_coarse_mat_</code>  <BR><code>COARSE_MAT</code></TD>
<TD ALIGN="LEFT"><code>character(len=*)</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91><TT>'DISTR'</TT>   <TT>'REPL'</TT></TD>
<TD ALIGN="LEFT"><TT>'DISTR'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Coarsest matrix: distributed among the processors or
                           replicated on each of them.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><code>mld_coarse_solve_</code> <BR><code>COARSE_SOLVE</code></TD>
<TD ALIGN="LEFT"><code>character(len=*)</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91><TT>'BJAC'</TT>   <TT>'UMF'</TT>  
                           <TT>'SLU'</TT>   <TT>'SLUDIST'</TT></TD>
<TD ALIGN="LEFT"><TT>'BJAC'</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Solver used at the coarsest level: block Jacobi, sequential
                           LU from UMFPACK, sequential LU from SuperLU, 
                           distributed LU from SuperLU_Dist.
                           <TT>'SLUDIST'</TT> requires the coarsest 
                           matrix to be distributed, while <TT>'UMF'</TT> and
                           <TT>'SLU'</TT> require it to be replicated.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><code>mld_coarse_subsolve_</code> <BR><code>COARSE_SUBSOLVE</code></TD>
<TD ALIGN="LEFT"><code>character(len=*)</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91><TT>'ILU'</TT>   <TT>'MILU'</TT>
                             <TT>'ILUT'</TT>
                             <TT>'UMF'</TT>   <TT>'SLU'</TT></TD>
<TD ALIGN="LEFT">See note</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Solver for the diagonal blocks of the coarse matrix,
                           in case the block Jacobi solver
                           is chosen as coarsest-level solver: ILU(<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img35.png"
 ALT="$p$"></SPAN>), MILU(<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img35.png"
 ALT="$p$"></SPAN>),
                           ILU(<SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img36.png"
 ALT="$p,t$"></SPAN>), LU from UMFPACK,
                           LU from SuperLU, plus triangular solve.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><code>mld_coarse_sweeps_</code> <BR><code>COARSE_SWEEPS</code></TD>
<TD ALIGN="LEFT"><code>integer</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91>Any&nbsp;int.&nbsp;num.&nbsp;<SPAN CLASS="MATH"><IMG
 WIDTH="32" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img99.png"
 ALT="$&gt; 0$"></SPAN></TD>
<TD ALIGN="LEFT">4</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Number of Block-Jacobi sweeps when 'BJAC' is used as
                           coarsest-level solver.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><code>mld_coarse_fillin_</code> <BR><code>COARSE_FILLIN</code></TD>
<TD ALIGN="LEFT"><code>integer</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91>Any&nbsp;int.&nbsp;num.&nbsp;<SPAN CLASS="MATH"><IMG
 WIDTH="32" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img90.png"
 ALT="$\ge 0$"></SPAN></TD>
<TD ALIGN="LEFT">0</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Fill-in level <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img35.png"
 ALT="$p$"></SPAN> of the incomplete LU factorizations.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><code>mld_coarse_iluthrs_</code>  <BR><code>COARSE_ILUTHRS</code></TD>
<TD ALIGN="LEFT"><code>real(</code><SPAN  CLASS="textit">kind_parameter</SPAN><code>)</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=91>Any&nbsp;real.&nbsp;num.&nbsp;<SPAN CLASS="MATH"><IMG
 WIDTH="32" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img90.png"
 ALT="$\ge 0$"></SPAN></TD>
<TD ALIGN="LEFT">0</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Drop tolerance <SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img91.png"
 ALT="$t$"></SPAN> in the ILU(<SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img36.png"
 ALT="$p,t$"></SPAN>) factorization.</TD>
</TR>
<TR><TD ALIGN="LEFT" COLSPAN=5><SPAN><B>Note:</B> defaults for
  <TT>m</TT>ld_coarse_subsolve_ are chosen as </SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" COLSPAN=5><SPAN>single precision version: 'SLU' if installed, 'ILU' otherwise</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT" COLSPAN=5><SPAN>double precision version: 'UMF' if installed,
  else 'SLU' if installed, 'ILU' otherwise</SPAN></TD>
</TR>
</TABLE>
</DIV>
</TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>

<P>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html284"
  HREF="node19.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html280"
  HREF="node16.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html274"
  HREF="node17.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html282"
  HREF="node2.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html285"
  HREF="node19.html">Subroutine mld_precbld</A>
<B> Up:</B> <A NAME="tex2html281"
  HREF="node16.html">User Interface</A>
<B> Previous:</B> <A NAME="tex2html275"
  HREF="node17.html">Subroutine mld_precinit</A>
 &nbsp; <B>  <A NAME="tex2html283"
  HREF="node2.html">Contents</A></B> </DIV>
<!--End of Navigation Panel-->

</BODY>
</HTML>
